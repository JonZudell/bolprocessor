short CurrentVref
long CurrentDir
int ScriptW,CurrentChannel;

These are only used by running scripts (or when setting up to run a script).
CurrentDir/Vref are used to make specs for loading files.


short LastVref
long LastDir

These are initialized to BP2's startup folder, and afterwards updated everytime
that MyOpen() opens a file, but they are never used for anything.  (Could be
used to set the default folder for open/save dialogs).


int OkWait

Usually TRUE but set FALSE by the "Prompt OFF" script command.  WaitForNoteOn(),
WaitForTags(), and WaitKeyStrokeOrAppleEvent() will not run if this is set to
FALSE and MakeSound() will not wait for a "synchronized start" if FALSE. 
Answer() will return its default choice when (AEventOn && !OkWait).  This could
be a good mechanism to prevent user interaction in console/library build (??)
but notes that OkWait is also frequently reset to TRUE or 'OK' at the end of
processes.  (A console option could reenable?)


int ReadKeyBoardOn
int Jcontrol
int Interactive

ReadKeyBoardOn is set to TRUE whenever BP2 is reading Midi input as an immediate
user input source (eg. typing note names, getting the # or value of a controller
to enter into a document or dialog field(?)).

Jcontrol is the number of the performance control being read. (-1 == none)

Interactive is TRUE when the "Interactive (use input)" button is checked on the 
lower "Settings" dialog and BP2 is listening to Midi input for triggers and
parameter controllers (K1, etc.) set in the Interaction and Grammar(?) files.

When OMS was the Midi driver, ListenMIDI() would not proceed unless at least one
of ReadKeyBoardOn, Interactive, or ScriptRecOn was TRUE.  (The CoreMIDI driver
should perhaps be changed to work like the OMS one).


int Varweight
int Flagthere
int ResetDone

Varweight is TRUE if any grammar rule has a weight with an increment.
Flagthere is TRUE if any grammar rule has a flag.

ResetDone is set TRUE at the end of ResetRuleWeights() and FALSE after computing
in ProduceItems() and CheckItemProduced().  It's value does not actually seem to 
be checked and used anywhere though.


int Ndiagram
PolyHandle p_Diagram[MAXDIAGRAM];
int DiagramWindow[MAXDIAGRAM];


int ObjectMode
int ObjectTry

ObjectMode indicates that an object prototypes (-mi) file has been loaded (?).
These two flags are almost always set, cleared, and tested together.  ObjectTry
seems to only be set TRUE by itself in CheckLoadedPrototypes() if the user
refuses to load prototypes or LoadObjectPrototypes() fails.  In other cases
where LoadObjectPrototypes() fails, both are set to FALSE. Looks like if either
is TRUE, then many attempts to load prototypes are skipped.


int	iProto

iProto is the index of the currently-displayed prototype in the GUI.


int EventState

EventState is used primarily to convey the status from received Apple Events.
Its default value ("do nothing") is NO.  EXIT means that BP2 should quit.
Other values like ABORT, AGAIN, QUICK, and RESUME are used to signal when
the real-time improvisation AEs are received.


int SkipFlag

Skips playing the next item when TRUE.  Can be set by an Apple Event or a Midi
message determined in the interaction file.


char ****p_GramProcedure
int **p_ProcNdx
int **p_ProcNArg
long MaxProc

char ****p_PerformanceControl
int **p_PerfCtrlNdx
int **p_PerfCtrlNArg
long MaxPerformanceControl

p_GramProcedure and p_PerformanceControl are two lists of the names of functions
that can be used in grammars (such _goto and _volume).  p_ProcNArg and
p_PerfCtrlNArg are arrays specifying the number of arguments that each function
takes; MaxProc and MaxPerformanceControl are the lengths of these lists.

p_ProcNdx and p_PerfCtrlNdx are the same dimensions as p_GramProcedure and
p_PerformanceControl respectively but don't store values that "belong" to their
corresponding functions in those lists.  Instead, they are like reverse indexes
that are used only by DoThings() and mListReserved() to sort the grammar
function names for display & selection.  mPickPerformanceControl() and
mPickGrammarProcedure() use these indexes to retrieve the function selected by
the user in DoThings().  Here is how they work:

DoThings() and mListReserved() iterate over p_ProcNdx or p_PerfCtrlNdx and 
display functions in these orders (omitting (*handle) dereferences):

    p_GramProcedure[ p_ProcNdx[0 to (MaxProc-1)] ]
    p_PerformanceControl[ p_PerfCtrlNdx[0 to (MaxPerformanceControl-1)] ]

DoThings() returns the index r of the selected function from its "sorted
order".  mPickPerformanceControl() and mPickGrammarProcedure() then use either

    p_GramProcedure[ p_ProcNdx[r] ]
    p_PerformanceControl[ p_PerfCtrlNdx[r] ]

to find the correct function to insert.  For example, if the user selects
"_destru" from the list, DoThings() returns r=0 and p_ProcNdx[0] is 11,
so mPickGrammarProcedure() prints p_GramProcedure[11] into the window.

     r    user selection    p_ProcNdx[r]    p_GramProcedure[r]
     ---------------------------------------------------------
     0    _destru           11              _goto
     1    _goto             0               _failed
     2    _failed           1               _repeat
     3    _mm               13              _stop
     4    _print            4               _print
     5    _printOff         6               _printOn
     6    _printOn          5               _printOff
     7    _randomize        12              _stepOn
     8    _repeat           2               _stepOff
     9    _smooth           15              _traceOn
    10    _srand            16              _traceOff
    11    _stepOff          8               _destru
    12    _stepOn           7               _randomize
    13    _stop             3               _mm
    14    _striated         14              _striated
    15    _traceOff         10              _smooth
    16    _traceOn          9               _srand

Note: Since the intention of p_ProcNdx and p_PerfCtrlNdx seems to be to provide
an alphabetically-sorted order for the function names, it would be easier to
maintain these lists if the sort indices were generated at runtime by BP2.
(Notice that the current order of p_ProcNdx contains an "error").

IMPORTANT:  The order of these lists of names cannot currently be "pre-sorted"
because other parts of the program use literal constants to refer to specific
entries in p_GramProcedure and p_PerformanceControl.  These literal constants
should be replaced by enums.


char ****p_GeneralMIDIpatch
int **p_GeneralMIDIpatchNdx

Stores a list of General MIDI patch names and their program numbers (1 to 128).
Like the string lists above but always 128 entries and since they are kept in
sorted order, the value of p_GeneralMIDIpatchNdx[N] == N + 1.  The code however
does not seem to assume they are sorted and searches for program numbers when
needed.  Could probably simplify this by imposing a requirement that the names
be sorted in program number order.


